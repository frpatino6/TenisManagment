# Tennis Management Project - Cursor Rules

## Project Overview
This is a tennis management system with:
- Backend: TypeScript/Node.js with Express, MongoDB, Firebase Auth
- Mobile: Flutter/Dart with Firebase integration
- Architecture: Clean Architecture with Domain-Driven Design

## General Rules

### Code Style & Standards
- Use TypeScript strict mode for backend
- Follow Dart/Flutter conventions for mobile
- Use meaningful variable and function names
- Write self-documenting code with clear intent
- Prefer composition over inheritance
- Use async/await over Promises where possible
- Handle errors explicitly with proper error messages

### File Organization
- Keep related files together
- Use barrel exports (index.ts) for clean imports
- Separate concerns into appropriate layers (domain, application, infrastructure, presentation)
- Follow the existing folder structure

### Backend Specific Rules

#### Architecture
- Follow Clean Architecture principles
- Domain entities should be pure business logic
- Use cases contain application logic
- Controllers handle HTTP concerns
- Repositories abstract data access
- Use dependency injection for loose coupling

#### TypeScript
- Use strict TypeScript configuration
- Define proper interfaces and types
- Use generics for reusable components
- Prefer type safety over any
- Use enums for constants
- Implement proper error handling with custom error classes
- **ALWAYS run `tsc --noEmit` before committing** - Check TypeScript compilation
- **ALWAYS fix TypeScript errors** - No commits with type errors
- **ALWAYS validate imports and exports** - Ensure module resolution works

#### Database & Models
- Use Mongoose schemas with proper validation
- Implement proper indexing for performance
- Use transactions for data consistency
- Validate data at both schema and application level
- **ALWAYS use MCP to verify database schema** - Consult MCP before creating or modifying schemas
- **ALWAYS use MCP to validate data relationships** - Confirm foreign keys and references with MCP
- **ALWAYS use MCP for MongoDB queries** - Verify query syntax and aggregation pipelines with MCP
- **ALWAYS use MCP to search existing repository methods** - Check if similar database operations already exist
- **ALWAYS use MCP to analyze existing queries** - Verify query patterns and reuse existing repository methods
- **ALWAYS use MCP to check for duplicate database logic** - Avoid creating redundant database operations

#### API Design
- Use RESTful conventions
- Implement proper HTTP status codes
- Use consistent response formats
- Add proper request/response validation
- Implement rate limiting and security headers
- **NEVER create debug APIs or endpoints** - Use proper logging instead
- **NO temporary debug routes** in production code
- Use environment variables for debug configurations

#### Authentication & Security
- Use Firebase Auth for authentication
- Implement proper middleware for route protection
- Validate all inputs
- Use environment variables for sensitive data
- Implement proper CORS configuration

### Mobile Specific Rules (Flutter/Dart)

#### Architecture
- Follow Clean Architecture with feature-based organization
- Use Provider or Riverpod for state management
- Separate UI, business logic, and data layers
- Use repositories for data access abstraction

#### Flutter Best Practices
- Use const constructors where possible
- Implement proper widget composition
- Use proper keys for widget identification
- Follow Material Design guidelines
- Implement responsive design
- Use proper error handling and loading states
- Follow Dart's official style guide and lint rules
- Use proper null safety patterns
- Prefer final over var when possible
- Use proper type annotations
- Implement proper async/await patterns
- **ALWAYS use `.withValues()` instead of deprecated `.withOpacity()`** - Use modern color opacity methods
- **ALWAYS use `.withValues(alpha: value)` for opacity** - Replace `color.withOpacity(value)` with `color.withValues(alpha: value)`
- **ALWAYS run `flutter analyze` before committing** - Check Dart static analysis
- **ALWAYS run `dart format` before committing** - Ensure consistent code formatting
- **ALWAYS fix Dart analyzer warnings** - No commits with analyzer issues
- **ALWAYS validate pubspec.yaml dependencies** - Ensure all packages are properly declared

#### State Management
- Keep UI state separate from business logic
- Use immutable state objects
- Implement proper state validation
- Handle async operations with proper loading states

#### Firebase Integration
- Use proper Firebase security rules
- Implement offline support where appropriate
- Handle authentication state properly
- Use proper error handling for Firebase operations
- **NO debug API calls** - Use proper error handling and logging instead
- **NO temporary debug endpoints** in API calls
- **ALWAYS use MCP to verify Firebase data structure** - Consult MCP for Firestore schema and rules
- **ALWAYS use MCP to validate API responses** - Confirm data format and types with MCP
- **ALWAYS use MCP to search existing service methods** - Check if similar API calls already exist
- **ALWAYS use MCP to analyze existing API patterns** - Verify service patterns and reuse existing methods
- **ALWAYS use MCP to check for duplicate API calls** - Avoid creating redundant service operations

### Testing
- Write unit tests for business logic
- Write integration tests for API endpoints
- Write widget tests for Flutter components
- Aim for high test coverage
- Use proper mocking for external dependencies

### Performance
- Optimize database queries
- Implement proper caching strategies
- Use pagination for large datasets
- Optimize Flutter app performance
- Minimize API calls
- Use proper image optimization

### Documentation
- Write clear README files
- Document API endpoints
- Keep documentation up to date
- Use proper commit messages

### Code Comments Guidelines
- **Backend (TypeScript)**: Add comments only for complex business logic in headers
- **Mobile (Dart)**: 
  - NO comments inside widget methods - code should be self-explanatory
  - NO comments inside UI/widget code - use meaningful variable and method names
  - ONLY add header comments for business logic methods and classes
  - Focus on clear, self-documenting code with proper naming conventions
  - **ALWAYS use modern Flutter APIs** - Replace `color.withOpacity(value)` with `color.withValues(alpha: value)`

### Debug and Development Rules
- **NEVER create debug APIs or endpoints** - Use proper logging and development tools instead
- **NO debug routes or debug controllers** in production code
- **NO temporary debug endpoints** - Use environment-based configuration for debugging
- **NO debug-specific API routes** - Implement proper error handling and logging mechanisms
- Use proper development environments and tools for debugging instead of creating debug APIs

### Code Quality and Syntax Rules
- **ALWAYS check syntax errors before committing** - Run linter and fix all errors
- **ALWAYS compile and test before marking tasks as complete** - Ensure code compiles without errors
- **ALWAYS run type checking** - Fix TypeScript/Dart type errors before committing
- **ALWAYS validate imports and dependencies** - Ensure all imports are correct and available
- **ALWAYS check for unused imports** - Remove unused imports to keep code clean
- **NEVER commit code with syntax errors** - Fix all compilation errors first
- **ALWAYS run tests before deployment** - Ensure functionality works as expected
- **ALWAYS use modern API methods** - Replace deprecated methods with current alternatives
- **NEVER use deprecated Flutter methods** - Use `.withValues(alpha: value)` instead of `.withOpacity(value)`
- **ALWAYS check for deprecation warnings** - Fix all deprecation warnings before committing

### Database and Data Rules
- **ALWAYS use MCP to consult database structure** - Use MCP tools to clarify database schema and data
- **ALWAYS verify data models with MCP** - Confirm entity relationships and field types using MCP
- **ALWAYS consult MCP for data validation rules** - Use MCP to understand business logic constraints
- **ALWAYS use MCP for database queries** - Verify query syntax and performance with MCP tools
- **NEVER make assumptions about database structure** - Always consult MCP for accurate information
- **ALWAYS use MCP to resolve data inconsistencies** - Consult MCP when encountering data-related issues
- **ALWAYS analyze if query already exists before creating new ones** - Use MCP to check for existing similar queries and reuse when possible
- **ALWAYS search existing queries with MCP** - Verify if similar database operations already exist in the codebase
- **ALWAYS reuse existing queries when appropriate** - Avoid duplicating database logic, extend existing queries instead

### Version Management & Deployment Rules

#### Version Control & Updates
- **ALWAYS update version in pubspec.yaml FIRST** - Update version before any code changes
- **ALWAYS update version in package.json for backend** - Keep backend and frontend versions synchronized
- **NEVER hardcode version numbers in Dart/TypeScript code** - Use package_info_plus or environment variables
- **ALWAYS use semantic versioning (SemVer)** - Follow MAJOR.MINOR.PATCH format
- **ALWAYS increment build number** - Increment build number with each version update
- **ALWAYS verify version consistency** - Ensure all version references are updated

#### Version Update Process
**BEFORE updating version:**
1. **Check current version** - Verify current version in pubspec.yaml and package.json
2. **Determine version increment** - Decide if it's patch, minor, or major update
3. **Update pubspec.yaml** - Change version field (e.g., 1.3.0 â†’ 1.3.1)
4. **Update package.json** - Change version field in backend
5. **Search for hardcoded versions** - Find and update any hardcoded version strings in code
6. **Update build numbers** - Increment build numbers in hardcoded PackageInfo objects

**MANDATORY version update checklist:**
- [ ] pubspec.yaml version updated
- [ ] package.json version updated  
- [ ] All hardcoded version strings updated in Dart files
- [ ] All hardcoded build numbers updated
- [ ] No remaining old version references in codebase
- [ ] Version consistency verified across all files

#### Deployment Process
**BEFORE deploying to Firebase:**
1. **Clean build completely** - Run `flutter clean` and `rm -rf build/`
2. **Verify version in source** - Check pubspec.yaml has correct version
3. **Search for hardcoded versions** - Use `grep -r "1\.3\.[0-9]" lib/` to find hardcoded versions
4. **Update any hardcoded versions found** - Replace with current version
5. **Build with verbose output** - Run `flutter build web --release --verbose`
6. **Verify build contains correct version** - Check `grep -o "1\.3\.[0-9]" build/web/main.dart.js`
7. **Deploy to Firebase** - Run `firebase deploy --only hosting`
8. **Verify deployed version** - Check `curl -s https://tennis-management-fcd54.web.app/main.dart.js | grep -o "1\.3\.[0-9]"`

**NEVER deploy if:**
- Build contains old version numbers
- Hardcoded versions don't match pubspec.yaml
- Version verification fails
- Build process has errors

#### Version Hardcoding Prevention
- **NEVER hardcode versions in PackageInfo objects** - Use dynamic version retrieval
- **ALWAYS use package_info_plus for version display** - Avoid hardcoded version strings
- **ALWAYS search codebase for version strings** - Use grep to find hardcoded versions
- **ALWAYS update all version references** - Don't leave any old version strings
- **ALWAYS verify version consistency** - Ensure all files have same version

#### Common Version Update Commands
```bash
# Search for hardcoded versions
grep -r "1\.3\.[0-9]" lib/
grep -r "version.*1\.3\.[0-9]" lib/

# Clean and rebuild
flutter clean
rm -rf build/
flutter build web --release

# Verify version in build
grep -o "1\.3\.[0-9]" build/web/main.dart.js

# Deploy and verify
firebase deploy --only hosting
curl -s https://tennis-management-fcd54.web.app/main.dart.js | grep -o "1\.3\.[0-9]"
```

### Git & Version Control
- Use conventional commit messages
- Create feature branches for new development
- Keep commits atomic and focused
- Write meaningful pull request descriptions
- Use proper branch naming conventions
- **ALWAYS commit version updates separately** - Version updates should be isolated commits
- **ALWAYS include version in commit message** - Use format "chore: bump version to 1.3.2"

### Pre-Commit and Pre-Deployment Checklist
**BEFORE marking any task as complete or making commits:**
1. **Run syntax/type checking**:
   - Backend: `npm run build` or `tsc --noEmit`
   - Frontend: `flutter analyze` and `dart format`
2. **Fix all compilation errors** - No exceptions
3. **Remove unused imports** - Clean up dependencies
4. **Validate all imports** - Ensure modules resolve correctly
5. **Run linter** - Fix all linting warnings
6. **Test functionality** - Ensure features work as expected
7. **Check for debug code** - Remove any debug statements
8. **Verify environment variables** - Ensure configuration is correct
9. **Review code quality** - Follow established patterns
10. **Document changes** - Update relevant documentation if needed
11. **Consult MCP for database questions** - Use MCP tools to clarify any data-related doubts
12. **Verify data models with MCP** - Confirm database schema and relationships using MCP
13. **Use MCP to analyze existing queries** - Search for similar database operations before creating new ones
14. **Verify no duplicate queries exist** - Use MCP to check for existing similar functionality

**BEFORE deploying to Firebase (MANDATORY):**
15. **Check version consistency** - Verify pubspec.yaml and package.json have same version
16. **Search for hardcoded versions** - Run `grep -r "1\.3\.[0-9]" lib/` to find hardcoded versions
17. **Update hardcoded versions** - Replace any hardcoded version strings with current version
18. **Clean build completely** - Run `flutter clean` and `rm -rf build/`
19. **Build with verification** - Run `flutter build web --release --verbose`
20. **Verify build version** - Check `grep -o "1\.3\.[0-9]" build/web/main.dart.js` shows correct version
21. **Deploy to Firebase** - Run `firebase deploy --only hosting`
22. **Verify deployed version** - Check `curl -s https://tennis-management-fcd54.web.app/main.dart.js | grep -o "1\.3\.[0-9]"` shows correct version

**NEVER commit code that:**
- Has syntax errors
- Fails compilation
- Has linting warnings (unless explicitly documented)
- Contains debug code
- Has unused imports
- Breaks existing functionality
- Has unresolved database questions (always consult MCP first)
- Has hardcoded version numbers that don't match pubspec.yaml
- Has inconsistent version numbers across files
- Has old version references in PackageInfo objects

### MCP Usage Guidelines
**ALWAYS use MCP when:**
- Creating or modifying database schemas
- Writing database queries or aggregations
- Implementing data validation rules
- Handling data relationships and foreign keys
- Processing API responses with unknown structure
- Debugging data inconsistencies
- Implementing business logic with data constraints
- Working with Firebase/Firestore data structures
- **BEFORE creating new queries** - Use MCP to search for existing similar queries
- **BEFORE implementing new API calls** - Use MCP to check for existing service methods
- **BEFORE adding new repository methods** - Use MCP to analyze existing database operations

**MCP provides accurate information about:**
- Database schema and field types
- Data relationships and constraints
- Query syntax and performance optimization
- API response formats and data structures
- Business logic rules and validation requirements
- **Existing queries and database operations** - Search for similar functionality
- **Existing service methods and API calls** - Check for duplicate operations
- **Query patterns and best practices** - Analyze existing code patterns

**Query Analysis Process with MCP:**
1. **Search existing queries** - Use MCP to find similar database operations
2. **Analyze query patterns** - Review existing query structures and logic
3. **Check for reusability** - Determine if existing queries can be extended
4. **Verify performance** - Compare with existing optimized queries
5. **Avoid duplication** - Reuse or extend existing queries when appropriate

### Security Considerations
- Never commit secrets or API keys
- Use environment variables for configuration
- Implement proper input validation
- Use HTTPS for all communications
- Implement proper authentication and authorization
- Regular dependency updates for security patches

### Code Review Guidelines
- Review for security vulnerabilities
- Check for performance implications
- Ensure proper error handling
- Verify test coverage
- Check for code duplication
- Ensure proper documentation

## Common Patterns

### Error Handling
```typescript
// Backend
try {
  const result = await someOperation();
  return res.status(200).json({ success: true, data: result });
} catch (error) {
  console.error('Operation failed:', error);
  return res.status(500).json({ 
    success: false, 
    message: 'Internal server error' 
  });
}
```

### API Response Format
```typescript
// Success response
{
  success: true,
  data: T,
  message?: string
}

// Error response
{
  success: false,
  message: string,
  errors?: any[]
}
```

### Flutter Widget Structure
```dart
class FeatureWidget extends StatelessWidget {
  const FeatureWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    return Column(
      children: [
        _buildHeader(),
        _buildContent(),
      ],
    );
  }

  Widget _buildHeader() {
    return AppBar(title: Text('Feature'));
  }

  Widget _buildContent() {
    return Expanded(
      child: ListView.builder(
        itemBuilder: (context, index) => _buildListItem(index),
      ),
    );
  }

  Widget _buildListItem(int index) {
    return ListTile(
      title: Text('Item $index'),
    );
  }
}
```

### Business Logic Structure
```dart
/// Handles user authentication and session management
class AuthService {
  /// Authenticates user with email and password
  /// Returns [AuthResult] with success status and user data
  Future<AuthResult> authenticateUser(String email, String password) async {
    try {
      final credential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (credential.user != null) {
        return AuthResult.success(credential.user!);
      }
      
      return AuthResult.failure('Authentication failed');
    } catch (e) {
      return AuthResult.failure(e.toString());
    }
  }
}
```

## Tools & Dependencies
- Backend: Express, MongoDB, Firebase, TypeScript, ESLint
- Mobile: Flutter, Firebase, Provider/Riverpod
- Development: VS Code, Cursor, Git

## Environment Setup
- Use Node.js 18+ for backend
- Use Flutter 3.0+ for mobile
- Configure Firebase properly for both projects
- Set up proper environment variables
- Use proper linting and formatting tools

Remember: Always prioritize code quality, security, and maintainability over speed of development.
