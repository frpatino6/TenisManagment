# Tennis Management Project - Cursor Rules

## Project Overview
This is a tennis management system with:
- Backend: TypeScript/Node.js with Express, MongoDB, Firebase Auth
- Mobile: Flutter/Dart with Firebase integration
- Architecture: Clean Architecture with Domain-Driven Design

## General Rules

### ğŸš¨ CRITICAL: User Story Development Workflow (MANDATORY)
**BEFORE starting ANY user story development:**

#### âš ï¸ MANDATORY FIRST STEP - CREATE BRANCH:
**If you are working on ANY Linear issue (TEN-XXX), you MUST execute these commands FIRST:**

```bash
# 1. Check current branch
git branch

# 2. Switch to main branch
git checkout main

# 3. Pull latest changes
git pull origin main

# 4. Create feature branch (replace TEN-XXX with actual issue number)
git checkout -b feature/TEN-XXX-short-description

# 5. Verify branch was created
git branch
```

**EXAMPLE for US-001:**
```bash
git checkout main
git pull origin main
git checkout -b feature/TEN-001-modelo-datos-mensajes
git branch
```

#### ğŸ“‹ BRANCH CREATION RULES:
- **ALWAYS create a feature branch for each user story** - Each Linear issue must have its own branch
- **ALWAYS use Linear issue number in branch name** - Format: `feature/TEN-XXX-short-description`
- **ALWAYS create branch BEFORE starting development** - Never develop directly on main branch
- **ALWAYS update Linear issue status** - Move to "In Progress" when starting, "Done" when complete
- **NEVER work on main branch** - Always work on feature branches

#### Branch Naming Convention for User Stories:
```bash
# Format: feature/TEN-XXX-short-description
feature/TEN-001-modelo-datos-mensajes
feature/TEN-002-api-mensajeria
feature/TEN-003-middleware-autenticacion
feature/TEN-004-endpoints-chat
```

#### User Story Development Process (MANDATORY):
1. **Create branch from main** - `git checkout -b feature/TEN-XXX-description`
2. **Update Linear issue status** - Move to "In Progress" in Linear
3. **Develop feature** - Implement according to acceptance criteria
4. **Test thoroughly** - Ensure all criteria are met
5. **Commit with issue reference** - `git commit -m "feat(TEN-XXX): implement feature description"`
6. **Create pull request** - Reference Linear issue in PR description
7. **Update Linear issue** - Move to "Done" when PR is merged
8. **Delete feature branch** - Clean up after merge

#### Linear Issue Integration (MANDATORY):
- **ALWAYS link commits to Linear issues** - Use issue number in commit messages
- **ALWAYS update issue status** - Reflect current development state
- **ALWAYS reference Linear issue in PR** - Include issue link in pull request
- **ALWAYS verify acceptance criteria** - Ensure all criteria are met before marking done

### Code Style & Standards
- Use TypeScript strict mode for backend
- Follow Dart/Flutter conventions for mobile
- Use meaningful variable and function names
- Write self-documenting code with clear intent
- Prefer composition over inheritance
- Use async/await over Promises where possible
- Handle errors explicitly with proper error messages

### File Organization
- Keep related files together
- Use barrel exports (index.ts) for clean imports
- Separate concerns into appropriate layers (domain, application, infrastructure, presentation)
- Follow the existing folder structure

### Backend Specific Rules

#### Architecture
- Follow Clean Architecture principles
- Domain entities should be pure business logic
- Use cases contain application logic
- Controllers handle HTTP concerns
- Repositories abstract data access
- Use dependency injection for loose coupling
- **CRITICAL: Maintain clean architecture in all code** - Apply when creating AND editing files

#### TypeScript
- Use strict TypeScript configuration
- Define proper interfaces and types
- Use generics for reusable components
- Prefer type safety over any
- Use enums for constants
- Implement proper error handling with custom error classes
- **ALWAYS run `tsc --noEmit` before committing** - Check TypeScript compilation
- **ALWAYS fix TypeScript errors** - No commits with type errors
- **ALWAYS validate imports and exports** - Ensure module resolution works

#### SOLID Principles
- **CRITICAL: Apply SOLID principles when creating OR modifying backend files (.ts)**
- **Single Responsibility**: Each class/function should have one reason to change
- **Open/Closed**: Open for extension, closed for modification
- **Liskov Substitution**: Derived classes must be substitutable for their base classes
- **Interface Segregation**: Clients should not depend on interfaces they don't use
- **Dependency Inversion**: Depend on abstractions, not concretions
- Apply these principles consistently in all TypeScript code

#### Database & Models
- Use Mongoose schemas with proper validation
- Implement proper indexing for performance
- Use transactions for data consistency
- Validate data at both schema and application level
- **ALWAYS use MCP to verify database schema** - Consult MCP before creating or modifying schemas
- **ALWAYS use MCP to validate data relationships** - Confirm foreign keys and references with MCP
- **ALWAYS use MCP for MongoDB queries** - Verify query syntax and aggregation pipelines with MCP
- **ALWAYS use MCP to search existing repository methods** - Check if similar database operations already exist
- **ALWAYS use MCP to analyze existing queries** - Verify query patterns and reuse existing repository methods
- **ALWAYS use MCP to check for duplicate database logic** - Avoid creating redundant database operations

#### API Design
- Use RESTful conventions
- Implement proper HTTP status codes
- Use consistent response formats
- Add proper request/response validation
- Implement rate limiting and security headers
- **NEVER create debug APIs or endpoints** - Use proper logging instead
- **NO temporary debug routes** in production code
- Use environment variables for debug configurations

#### Authentication & Security
- Use Firebase Auth for authentication
- Implement proper middleware for route protection
- Validate all inputs
- Use environment variables for sensitive data
- Implement proper CORS configuration

### Mobile Specific Rules (Flutter/Dart)

#### Architecture
- Follow Clean Architecture with feature-based organization
- Use Provider or Riverpod for state management
- Separate UI, business logic, and data layers
- Use repositories for data access abstraction
- **CRITICAL: Maintain clean architecture in all code** - Apply when creating AND editing files

#### Flutter Best Practices
- Use const constructors where possible
- Implement proper widget composition
- Use proper keys for widget identification
- Follow Material Design guidelines
- Implement responsive design
- Use proper error handling and loading states
- Follow Dart's official style guide and lint rules
- Use proper null safety patterns
- Prefer final over var when possible
- Use proper type annotations
- Implement proper async/await patterns
- **ALWAYS use `.withValues()` instead of deprecated `.withOpacity()`** - Use modern color opacity methods
- **ALWAYS use `.withValues(alpha: value)` for opacity** - Replace `color.withOpacity(value)` with `color.withValues(alpha: value)`
- **ALWAYS run `flutter analyze` before committing** - Check Dart static analysis
- **ALWAYS run `dart format` before committing** - Ensure consistent code formatting
- **ALWAYS fix Dart analyzer warnings** - No commits with analyzer issues
- **ALWAYS validate pubspec.yaml dependencies** - Ensure all packages are properly declared

#### SOLID Principles
- **CRITICAL: Apply SOLID principles when creating OR modifying frontend files (.dart)**
- **Single Responsibility**: Each class/function should have one reason to change
- **Open/Closed**: Open for extension, closed for modification
- **Liskov Substitution**: Derived classes must be substitutable for their base classes
- **Interface Segregation**: Clients should not depend on interfaces they don't use
- **Dependency Inversion**: Depend on abstractions, not concretions
- Apply these principles consistently in all Dart code

#### State Management
- Keep UI state separate from business logic
- Use immutable state objects
- Implement proper state validation
- Handle async operations with proper loading states

#### Firebase Integration
- Use proper Firebase security rules
- Implement offline support where appropriate
- Handle authentication state properly
- Use proper error handling for Firebase operations
- **NO debug API calls** - Use proper error handling and logging instead
- **NO temporary debug endpoints** in API calls
- **ALWAYS use MCP to verify Firebase data structure** - Consult MCP for Firestore schema and rules
- **ALWAYS use MCP to validate API responses** - Confirm data format and types with MCP
- **ALWAYS use MCP to search existing service methods** - Check if similar API calls already exist
- **ALWAYS use MCP to analyze existing API patterns** - Verify service patterns and reuse existing methods
- **ALWAYS use MCP to check for duplicate API calls** - Avoid creating redundant service operations

### Testing
- Write unit tests for business logic
- Write integration tests for API endpoints
- Write widget tests for Flutter components
- Aim for high test coverage
- Use proper mocking for external dependencies
- **CRITICAL: When modifying backend code, ALWAYS review related tests and update them accordingly**
- **ALWAYS update tests when making backend changes** - Ensure test coverage is maintained or improved
- **ALWAYS run tests after backend modifications** - Verify all tests pass before committing

### Performance
- Optimize database queries
- Implement proper caching strategies
- Use pagination for large datasets
- Optimize Flutter app performance
- Minimize API calls
- Use proper image optimization

### Documentation
- Write clear README files
- Document API endpoints
- Keep documentation up to date
- Use proper commit messages

### Code Comments Guidelines
- **CRITICAL: For ALL .dart and .ts files (when creating OR editing files)**
- **Backend (TypeScript)**: Add comments only for complex business logic in headers
  - Do NOT add inline comments between lines of code
  - Only add comments at the class level (class documentation)
  - Use meaningful class names and method names instead of inline comments
  - This rule applies to file creation AND code modification
- **Mobile (Dart)**: 
  - NO comments inside widget methods - code should be self-explanatory
  - NO comments inside UI/widget code - use meaningful variable and method names
  - NO inline comments between lines of code
  - ONLY add header comments for business logic methods and classes (class-level documentation)
  - Focus on clear, self-documenting code with proper naming conventions
  - This rule applies to file creation AND code modification
  - **ALWAYS use modern Flutter APIs** - Replace `color.withOpacity(value)` with `color.withValues(alpha: value)`

### Debug and Development Rules
- **NEVER create debug APIs or endpoints** - Use proper logging and development tools instead
- **NO debug routes or debug controllers** in production code
- **NO temporary debug endpoints** - Use environment-based configuration for debugging
- **NO debug-specific API routes** - Implement proper error handling and logging mechanisms
- Use proper development environments and tools for debugging instead of creating debug APIs

### Code Quality and Syntax Rules
- **ALWAYS check syntax errors before committing** - Run linter and fix all errors
- **ALWAYS compile and test before marking tasks as complete** - Ensure code compiles without errors
- **ALWAYS run type checking** - Fix TypeScript/Dart type errors before committing
- **ALWAYS validate imports and dependencies** - Ensure all imports are correct and available
- **ALWAYS check for unused imports** - Remove unused imports to keep code clean
- **NEVER commit code with syntax errors** - Fix all compilation errors first
- **ALWAYS run tests before deployment** - Ensure functionality works as expected
- **ALWAYS use modern API methods** - Replace deprecated methods with current alternatives
- **NEVER use deprecated Flutter methods** - Use `.withValues(alpha: value)` instead of `.withOpacity(value)`
- **ALWAYS check for deprecation warnings** - Fix all deprecation warnings before committing

### Database and Data Rules
- **ALWAYS use MCP to consult database structure** - Use MCP tools to clarify database schema and data
- **ALWAYS verify data models with MCP** - Confirm entity relationships and field types using MCP
- **ALWAYS consult MCP for data validation rules** - Use MCP to understand business logic constraints
- **ALWAYS use MCP for database queries** - Verify query syntax and performance with MCP tools
- **NEVER make assumptions about database structure** - Always consult MCP for accurate information
- **ALWAYS use MCP to resolve data inconsistencies** - Consult MCP when encountering data-related issues
- **ALWAYS analyze if query already exists before creating new ones** - Use MCP to check for existing similar queries and reuse when possible
- **ALWAYS search existing queries with MCP** - Verify if similar database operations already exist in the codebase
- **ALWAYS reuse existing queries when appropriate** - Avoid duplicating database logic, extend existing queries instead

### Version Management & Deployment Rules

#### Version Control & Updates
- **ALWAYS update version in pubspec.yaml FIRST** - Update version before any code changes
- **ALWAYS update version in package.json for backend** - Keep backend and frontend versions synchronized
- **NEVER hardcode version numbers in Dart/TypeScript code** - Use package_info_plus or environment variables
- **ALWAYS use semantic versioning (SemVer)** - Follow MAJOR.MINOR.PATCH format
- **ALWAYS increment build number** - Increment build number with each version update
- **ALWAYS verify version consistency** - Ensure all version references are updated

#### Render Deployment Rules
- **ALWAYS increment backend version before deploying to Render** - When deploying backend changes to Render, MUST increment version in package.json
- **ALWAYS check for backend changes before Render deployment** - If there are any changes in the backend code, increment version
- **ALWAYS commit version increment separately** - Version bump should be a separate commit before deployment
- **ALWAYS use semantic versioning for Render deployments** - Follow MAJOR.MINOR.PATCH format for backend version updates
- **ALWAYS verify version increment in package.json** - Ensure version is properly updated before Render deployment
- **NEVER deploy to Render without version increment** - If backend has changes, version MUST be incremented first

#### Version Update Process
**BEFORE updating version:**
1. **Check current version** - Verify current version in pubspec.yaml and package.json
2. **Determine version increment** - Decide if it's patch, minor, or major update
3. **Update pubspec.yaml** - Change version field (e.g., 1.3.0 â†’ 1.3.1)
4. **Update package.json** - Change version field in backend
5. **Search for hardcoded versions** - Find and update any hardcoded version strings in code
6. **Update build numbers** - Increment build numbers in hardcoded PackageInfo objects

**MANDATORY version update checklist:**
- [ ] pubspec.yaml version updated
- [ ] package.json version updated  
- [ ] All hardcoded version strings updated in Dart files
- [ ] All hardcoded build numbers updated
- [ ] No remaining old version references in codebase
- [ ] Version consistency verified across all files

#### Deployment Process

**BEFORE deploying to Render (Backend):**
1. **Check for backend changes** - Verify if there are any changes in backend code
2. **Increment version in package.json** - If changes exist, increment version (e.g., 1.3.2 â†’ 1.3.3)
3. **Commit version increment** - Make separate commit for version bump
4. **Verify build works** - Run `npm run build` to ensure code compiles
5. **Push to trigger Render deployment** - Push changes to trigger automatic deployment
6. **Monitor deployment** - Check Render dashboard for deployment status
7. **Verify deployment** - Test endpoints after deployment completes

**BEFORE deploying to Firebase (Frontend):**
1. **Clean build completely** - Run `flutter clean` and `rm -rf build/`
2. **Verify version in source** - Check pubspec.yaml has correct version
3. **Search for hardcoded versions** - Use `grep -r "1\.3\.[0-9]" lib/` to find hardcoded versions
4. **Update any hardcoded versions found** - Replace with current version
5. **Build with verbose output** - Run `flutter build web --release --verbose`
6. **Verify build contains correct version** - Check `grep -o "1\.3\.[0-9]" build/web/main.dart.js`
7. **Deploy to Firebase** - Run `firebase deploy --only hosting`
8. **Verify deployed version** - Check `curl -s https://tennis-management-fcd54.web.app/main.dart.js | grep -o "1\.3\.[0-9]"`

**NEVER deploy if:**
- Backend has changes but version not incremented (for Render)
- Build contains old version numbers
- Hardcoded versions don't match pubspec.yaml
- Version verification fails
- Build process has errors

#### Version Hardcoding Prevention
- **NEVER hardcode versions in PackageInfo objects** - Use dynamic version retrieval
- **ALWAYS use package_info_plus for version display** - Avoid hardcoded version strings
- **ALWAYS search codebase for version strings** - Use grep to find hardcoded versions
- **ALWAYS update all version references** - Don't leave any old version strings
- **ALWAYS verify version consistency** - Ensure all files have same version

#### Common Version Update Commands

**Backend (Render Deployment):**
```bash
# Check current version
grep '"version"' package.json

# Increment version (patch)
npm version patch

# Or increment manually in package.json
# 1.3.2 â†’ 1.3.3

# Build and verify
npm run build

# Commit version increment
git add package.json package-lock.json
git commit -m "chore: bump version to 1.3.3"

# Push to trigger Render deployment
git push origin main

# Verify deployment
curl https://tennis-management-backend.onrender.com/health
```

**Frontend (Firebase Deployment):**
```bash
# Search for hardcoded versions
grep -r "1\.3\.[0-9]" lib/
grep -r "version.*1\.3\.[0-9]" lib/

# Clean and rebuild
flutter clean
rm -rf build/
flutter build web --release

# Verify version in build
grep -o "1\.3\.[0-9]" build/web/main.dart.js

# Deploy and verify
firebase deploy --only hosting
curl -s https://tennis-management-fcd54.web.app/main.dart.js | grep -o "1\.3\.[0-9]"
```

### Git & Version Control
- Use conventional commit messages
- Create feature branches for new development
- Keep commits atomic and focused
- Write meaningful pull request descriptions
- Use proper branch naming conventions
- **ALWAYS commit version updates separately** - Version updates should be isolated commits
- **ALWAYS include version in commit message** - Use format "chore: bump version to 1.3.2"


### Pre-Commit and Pre-Deployment Checklist
**BEFORE marking any task as complete or making commits:**
0. **ğŸš¨ CRITICAL: Create feature branch for user stories** - If working on a Linear issue, MUST create branch first: `git checkout -b feature/TEN-XXX-description`
1. **Run syntax/type checking**:
   - Backend: `npm run build` or `tsc --noEmit`
   - Frontend: `flutter analyze` and `dart format`
2. **Fix all compilation errors** - No exceptions
3. **Remove unused imports** - Clean up dependencies
4. **Validate all imports** - Ensure modules resolve correctly
5. **Run linter** - Fix all linting warnings
6. **Test functionality** - Ensure features work as expected
7. **Check for debug code** - Remove any debug statements
8. **Verify environment variables** - Ensure configuration is correct
9. **Review code quality** - Follow established patterns
10. **Document changes** - Update relevant documentation if needed
11. **Consult MCP for database questions** - Use MCP tools to clarify any data-related doubts
12. **Verify data models with MCP** - Confirm database schema and relationships using MCP
13. **Use MCP to analyze existing queries** - Search for similar database operations before creating new ones
14. **Verify no duplicate queries exist** - Use MCP to check for existing similar functionality

**BEFORE deploying to Render (Backend - MANDATORY):**
15. **Check for backend changes** - Verify if there are any changes in backend code
16. **Increment version in package.json** - If changes exist, increment version (e.g., 1.3.2 â†’ 1.3.3)
17. **Commit version increment separately** - Make separate commit for version bump
18. **Verify build works** - Run `npm run build` to ensure code compiles
19. **Push to trigger deployment** - Push changes to trigger automatic Render deployment
20. **Monitor deployment status** - Check Render dashboard for deployment progress
21. **Verify deployment** - Test endpoints after deployment completes

**BEFORE deploying to Firebase (Frontend - MANDATORY):**
22. **Check version consistency** - Verify pubspec.yaml and package.json have same version
23. **Search for hardcoded versions** - Run `grep -r "1\.3\.[0-9]" lib/` to find hardcoded versions
24. **Update hardcoded versions** - Replace any hardcoded version strings with current version
25. **Clean build completely** - Run `flutter clean` and `rm -rf build/`
26. **Build with verification** - Run `flutter build web --release --verbose`
27. **Verify build version** - Check `grep -o "1\.3\.[0-9]" build/web/main.dart.js` shows correct version
28. **Deploy to Firebase** - Run `firebase deploy --only hosting`
29. **Verify deployed version** - Check `curl -s https://tennis-management-fcd54.web.app/main.dart.js | grep -o "1\.3\.[0-9]"` shows correct version

**NEVER commit code that:**
- Has syntax errors
- Fails compilation
- Has linting warnings (unless explicitly documented)
- Contains debug code
- Has unused imports
- Breaks existing functionality
- Has unresolved database questions (always consult MCP first)
- Has hardcoded version numbers that don't match pubspec.yaml
- Has inconsistent version numbers across files
- Has old version references in PackageInfo objects

### MCP Usage Guidelines
- **CRITICAL: Review active MCP (Model Context Protocol) tools before starting tasks**
- **ALWAYS check available MCP tools** - Review active MCP servers and use them when necessary
- **Use MCP tools when available and appropriate** - Leverage MCP to improve code quality and development efficiency

**ALWAYS use MCP when:**
- Creating or modifying database schemas
- Writing database queries or aggregations
- Implementing data validation rules
- Handling data relationships and foreign keys
- Processing API responses with unknown structure
- Debugging data inconsistencies
- Implementing business logic with data constraints
- Working with Firebase/Firestore data structures
- **BEFORE creating new queries** - Use MCP to search for existing similar queries
- **BEFORE implementing new API calls** - Use MCP to check for existing service methods
- **BEFORE adding new repository methods** - Use MCP to analyze existing database operations

**MCP provides accurate information about:**
- Database schema and field types
- Data relationships and constraints
- Query syntax and performance optimization
- API response formats and data structures
- Business logic rules and validation requirements
- **Existing queries and database operations** - Search for similar functionality
- **Existing service methods and API calls** - Check for duplicate operations
- **Query patterns and best practices** - Analyze existing code patterns

**Query Analysis Process with MCP:**
1. **Search existing queries** - Use MCP to find similar database operations
2. **Analyze query patterns** - Review existing query structures and logic
3. **Check for reusability** - Determine if existing queries can be extended
4. **Verify performance** - Compare with existing optimized queries
5. **Avoid duplication** - Reuse or extend existing queries when appropriate

### Security Considerations
- Never commit secrets or API keys
- Use environment variables for configuration
- Implement proper input validation
- Use HTTPS for all communications
- Implement proper authentication and authorization
- Regular dependency updates for security patches

### Code Review Guidelines
- Review for security vulnerabilities
- Check for performance implications
- Ensure proper error handling
- Verify test coverage
- Check for code duplication
- Ensure proper documentation

## Common Patterns

### Error Handling
```typescript
// Backend
try {
  const result = await someOperation();
  return res.status(200).json({ success: true, data: result });
} catch (error) {
  console.error('Operation failed:', error);
  return res.status(500).json({ 
    success: false, 
    message: 'Internal server error' 
  });
}
```

### API Response Format
```typescript
// Success response
{
  success: true,
  data: T,
  message?: string
}

// Error response
{
  success: false,
  message: string,
  errors?: any[]
}
```

### Flutter Widget Structure
```dart
class FeatureWidget extends StatelessWidget {
  const FeatureWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    return Column(
      children: [
        _buildHeader(),
        _buildContent(),
      ],
    );
  }

  Widget _buildHeader() {
    return AppBar(title: Text('Feature'));
  }

  Widget _buildContent() {
    return Expanded(
      child: ListView.builder(
        itemBuilder: (context, index) => _buildListItem(index),
      ),
    );
  }

  Widget _buildListItem(int index) {
    return ListTile(
      title: Text('Item $index'),
    );
  }
}
```

### Business Logic Structure
```dart
/// Handles user authentication and session management
class AuthService {
  /// Authenticates user with email and password
  /// Returns [AuthResult] with success status and user data
  Future<AuthResult> authenticateUser(String email, String password) async {
    try {
      final credential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (credential.user != null) {
        return AuthResult.success(credential.user!);
      }
      
      return AuthResult.failure('Authentication failed');
    } catch (e) {
      return AuthResult.failure(e.toString());
    }
  }
}
```

## Tools & Dependencies
- Backend: Express, MongoDB, Firebase, TypeScript, ESLint
- Mobile: Flutter, Firebase, Provider/Riverpod
- Development: VS Code, Cursor, Git

## Environment Setup
- Use Node.js 18+ for backend
- Use Flutter 3.0+ for mobile
- Configure Firebase properly for both projects
- Set up proper environment variables
- Use proper linting and formatting tools

## MCP Servers & External Integrations

### Linear Project Management (ALREADY CONFIGURED)
**IMPORTANT:** Linear MCP server is already set up and configured. When working with Linear:

#### Configuration Files:
- **Config Location:** `config/linear-config.env`
- **API Key:** Available in `config/linear-config.env` (LINEAR_API_KEY)
- **Team ID:** Available in `config/linear-config.env` (LINEAR_TEAM_ID)
- **Cursor Config:** `config/cursor_linear_config.json`

#### Available Scripts:
```bash
# Main Linear management
node scripts/linear-backlog-manager.js

# Sprint organization
node scripts/organize-sprints.js

# Sprint management
node scripts/sprint-management/start-sprint-1.js
node scripts/sprint-management/update-sprint-progress.js

# Linear utilities
node scripts/linear/check-issue-identifiers.js
node scripts/linear/associate-issues-correct.js
```

#### Working Directory:
- **Always work from:** `/home/fernando/Documentos/TenisManagment`
- **Scripts are in:** `scripts/` directory
- **Config is in:** `config/` directory

#### Linear Commands for AI Agents:
When asked to interact with Linear:
1. **Verify connection first:** `node scripts/linear-backlog-manager.js`
2. **Use existing scripts** instead of creating new ones
3. **Follow the established patterns** in the scripts directory
4. **Reference the correct file paths** (scripts/ and config/ directories)

### Render Deployment (ALREADY CONFIGURED)
**IMPORTANT:** Render deployment is already configured:

#### Configuration Files:
- **Render Config:** `config/render.yaml`
- **Environment Variables:** Set in Render dashboard
- **Build Commands:** Already configured in render.yaml

#### Deployment Commands:
```bash
# Deploy to Render (automatic via Git push)
git push origin main

# Check deployment status
# Use Render dashboard or CLI
```

#### Render Integration:
- **Auto-deploy:** Enabled on main branch push
- **Environment:** Production environment configured
- **Database:** MongoDB Atlas connected
- **Domain:** Custom domain configured

### MCP Server Usage Guidelines

#### For Linear Operations:
- **DO NOT** create new Linear API integrations
- **DO USE** existing scripts in `scripts/` directory
- **DO VERIFY** connection with `linear-backlog-manager.js` first
- **DO FOLLOW** established patterns and file structure

#### For Render Operations:
- **DO NOT** reconfigure deployment settings
- **DO USE** existing `render.yaml` configuration
- **DO PUSH** to main branch for automatic deployment
- **DO CHECK** Render dashboard for deployment status

#### File Structure Awareness:
```
TenisManagment/
â”œâ”€â”€ config/                    # All configuration files
â”‚   â”œâ”€â”€ linear-config.env     # Linear API configuration
â”‚   â”œâ”€â”€ cursor_linear_config.json # Cursor Linear integration
â”‚   â””â”€â”€ render.yaml           # Render deployment config
â”œâ”€â”€ scripts/                   # All automation scripts
â”‚   â”œâ”€â”€ linear/               # Linear-specific scripts
â”‚   â”œâ”€â”€ sprint-management/    # Sprint management scripts
â”‚   â””â”€â”€ [main scripts]        # Primary management scripts
â””â”€â”€ docs/                     # Documentation
    â”œâ”€â”€ analysis/             # Technical analysis
    â”œâ”€â”€ deployment/           # Deployment docs
    â””â”€â”€ sprints/              # Sprint documentation
```

#### When Working with External Services:
1. **Check existing configuration** before creating new integrations
2. **Use established scripts** and patterns
3. **Follow the organized file structure**
4. **Reference correct paths** (config/ and scripts/ directories)
5. **Verify connections** before performing operations

Remember: Always prioritize code quality, security, and maintainability over speed of development.

---

## ğŸš¨ğŸš¨ğŸš¨ FINAL REMINDER - BRANCH CREATION ğŸš¨ğŸš¨ğŸš¨

### âš ï¸ IF YOU ARE WORKING ON A LINEAR ISSUE (TEN-XXX), STOP EVERYTHING AND READ THIS:

**YOU MUST CREATE A FEATURE BRANCH BEFORE DOING ANYTHING ELSE!**

```bash
# STEP 1: Check what you're working on
# Are you working on TEN-001, TEN-002, TEN-003, etc.?

# STEP 2: Create the branch (replace TEN-XXX with your issue number)
git checkout main
git pull origin main
git checkout -b feature/TEN-XXX-description

# STEP 3: Verify you're on the new branch
git branch
```

**EXAMPLES:**
- For TEN-001: `git checkout -b feature/TEN-001-modelo-datos-mensajes`
- For TEN-002: `git checkout -b feature/TEN-002-api-mensajeria`
- For TEN-003: `git checkout -b feature/TEN-003-middleware-autenticacion`

**ğŸš€ AUTOMATIC BRANCH CREATION SCRIPT:**
```bash
# Use this script to automatically create the correct branch:
node scripts/create-feature-branch.js TEN-001
node scripts/create-feature-branch.js TEN-002
node scripts/create-feature-branch.js TEN-003
```

**This script will:**
1. Switch to main branch
2. Pull latest changes
3. Create the correct feature branch
4. Switch to the new branch
5. Verify everything is set up correctly

### ğŸš« NEVER WORK ON MAIN BRANCH
### âœ… ALWAYS WORK ON FEATURE BRANCHES
### ğŸ”„ ALWAYS CREATE BRANCH FIRST

**This is MANDATORY and NON-NEGOTIABLE!**
