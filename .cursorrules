# Tennis Management Project - Cursor Rules

## Project Overview
This is a tennis management system with:
- Backend: TypeScript/Node.js with Express, MongoDB, Firebase Auth
- Mobile: Flutter/Dart with Firebase integration
- Architecture: Clean Architecture with Domain-Driven Design

## General Rules

### Code Style & Standards
- Use TypeScript strict mode for backend
- Follow Dart/Flutter conventions for mobile
- Use meaningful variable and function names
- Write self-documenting code with clear intent
- Prefer composition over inheritance
- Use async/await over Promises where possible
- Handle errors explicitly with proper error messages

### File Organization
- Keep related files together
- Use barrel exports (index.ts) for clean imports
- Separate concerns into appropriate layers (domain, application, infrastructure, presentation)
- Follow the existing folder structure

### Backend Specific Rules

#### Architecture
- Follow Clean Architecture principles
- Domain entities should be pure business logic
- Use cases contain application logic
- Controllers handle HTTP concerns
- Repositories abstract data access
- Use dependency injection for loose coupling

#### TypeScript
- Use strict TypeScript configuration
- Define proper interfaces and types
- Use generics for reusable components
- Prefer type safety over any
- Use enums for constants
- Implement proper error handling with custom error classes
- **ALWAYS run `tsc --noEmit` before committing** - Check TypeScript compilation
- **ALWAYS fix TypeScript errors** - No commits with type errors
- **ALWAYS validate imports and exports** - Ensure module resolution works

#### Database & Models
- Use Mongoose schemas with proper validation
- Implement proper indexing for performance
- Use transactions for data consistency
- Validate data at both schema and application level
- **ALWAYS use MCP to verify database schema** - Consult MCP before creating or modifying schemas
- **ALWAYS use MCP to validate data relationships** - Confirm foreign keys and references with MCP
- **ALWAYS use MCP for MongoDB queries** - Verify query syntax and aggregation pipelines with MCP

#### API Design
- Use RESTful conventions
- Implement proper HTTP status codes
- Use consistent response formats
- Add proper request/response validation
- Implement rate limiting and security headers
- **NEVER create debug APIs or endpoints** - Use proper logging instead
- **NO temporary debug routes** in production code
- Use environment variables for debug configurations

#### Authentication & Security
- Use Firebase Auth for authentication
- Implement proper middleware for route protection
- Validate all inputs
- Use environment variables for sensitive data
- Implement proper CORS configuration

### Mobile Specific Rules (Flutter/Dart)

#### Architecture
- Follow Clean Architecture with feature-based organization
- Use Provider or Riverpod for state management
- Separate UI, business logic, and data layers
- Use repositories for data access abstraction

#### Flutter Best Practices
- Use const constructors where possible
- Implement proper widget composition
- Use proper keys for widget identification
- Follow Material Design guidelines
- Implement responsive design
- Use proper error handling and loading states
- Follow Dart's official style guide and lint rules
- Use proper null safety patterns
- Prefer final over var when possible
- Use proper type annotations
- Implement proper async/await patterns
- **ALWAYS use `.withValues()` instead of deprecated `.withOpacity()`** - Use modern color opacity methods
- **ALWAYS use `.withValues(alpha: value)` for opacity** - Replace `color.withOpacity(value)` with `color.withValues(alpha: value)`
- **ALWAYS run `flutter analyze` before committing** - Check Dart static analysis
- **ALWAYS run `dart format` before committing** - Ensure consistent code formatting
- **ALWAYS fix Dart analyzer warnings** - No commits with analyzer issues
- **ALWAYS validate pubspec.yaml dependencies** - Ensure all packages are properly declared

#### State Management
- Keep UI state separate from business logic
- Use immutable state objects
- Implement proper state validation
- Handle async operations with proper loading states

#### Firebase Integration
- Use proper Firebase security rules
- Implement offline support where appropriate
- Handle authentication state properly
- Use proper error handling for Firebase operations
- **NO debug API calls** - Use proper error handling and logging instead
- **NO temporary debug endpoints** in API calls
- **ALWAYS use MCP to verify Firebase data structure** - Consult MCP for Firestore schema and rules
- **ALWAYS use MCP to validate API responses** - Confirm data format and types with MCP

### Testing
- Write unit tests for business logic
- Write integration tests for API endpoints
- Write widget tests for Flutter components
- Aim for high test coverage
- Use proper mocking for external dependencies

### Performance
- Optimize database queries
- Implement proper caching strategies
- Use pagination for large datasets
- Optimize Flutter app performance
- Minimize API calls
- Use proper image optimization

### Documentation
- Write clear README files
- Document API endpoints
- Keep documentation up to date
- Use proper commit messages

### Code Comments Guidelines
- **Backend (TypeScript)**: Add comments only for complex business logic in headers
- **Mobile (Dart)**: 
  - NO comments inside widget methods - code should be self-explanatory
  - NO comments inside UI/widget code - use meaningful variable and method names
  - ONLY add header comments for business logic methods and classes
  - Focus on clear, self-documenting code with proper naming conventions
  - **ALWAYS use modern Flutter APIs** - Replace `color.withOpacity(value)` with `color.withValues(alpha: value)`

### Debug and Development Rules
- **NEVER create debug APIs or endpoints** - Use proper logging and development tools instead
- **NO debug routes or debug controllers** in production code
- **NO temporary debug endpoints** - Use environment-based configuration for debugging
- **NO debug-specific API routes** - Implement proper error handling and logging mechanisms
- Use proper development environments and tools for debugging instead of creating debug APIs

### Code Quality and Syntax Rules
- **ALWAYS check syntax errors before committing** - Run linter and fix all errors
- **ALWAYS compile and test before marking tasks as complete** - Ensure code compiles without errors
- **ALWAYS run type checking** - Fix TypeScript/Dart type errors before committing
- **ALWAYS validate imports and dependencies** - Ensure all imports are correct and available
- **ALWAYS check for unused imports** - Remove unused imports to keep code clean
- **NEVER commit code with syntax errors** - Fix all compilation errors first
- **ALWAYS run tests before deployment** - Ensure functionality works as expected
- **ALWAYS use modern API methods** - Replace deprecated methods with current alternatives
- **NEVER use deprecated Flutter methods** - Use `.withValues(alpha: value)` instead of `.withOpacity(value)`
- **ALWAYS check for deprecation warnings** - Fix all deprecation warnings before committing

### Database and Data Rules
- **ALWAYS use MCP to consult database structure** - Use MCP tools to clarify database schema and data
- **ALWAYS verify data models with MCP** - Confirm entity relationships and field types using MCP
- **ALWAYS consult MCP for data validation rules** - Use MCP to understand business logic constraints
- **ALWAYS use MCP for database queries** - Verify query syntax and performance with MCP tools
- **NEVER make assumptions about database structure** - Always consult MCP for accurate information
- **ALWAYS use MCP to resolve data inconsistencies** - Consult MCP when encountering data-related issues

### Git & Version Control
- Use conventional commit messages
- Create feature branches for new development
- Keep commits atomic and focused
- Write meaningful pull request descriptions
- Use proper branch naming conventions

### Pre-Commit and Pre-Deployment Checklist
**BEFORE marking any task as complete or making commits:**
1. **Run syntax/type checking**:
   - Backend: `npm run build` or `tsc --noEmit`
   - Frontend: `flutter analyze` and `dart format`
2. **Fix all compilation errors** - No exceptions
3. **Remove unused imports** - Clean up dependencies
4. **Validate all imports** - Ensure modules resolve correctly
5. **Run linter** - Fix all linting warnings
6. **Test functionality** - Ensure features work as expected
7. **Check for debug code** - Remove any debug statements
8. **Verify environment variables** - Ensure configuration is correct
9. **Review code quality** - Follow established patterns
10. **Document changes** - Update relevant documentation if needed
11. **Consult MCP for database questions** - Use MCP tools to clarify any data-related doubts
12. **Verify data models with MCP** - Confirm database schema and relationships using MCP

**NEVER commit code that:**
- Has syntax errors
- Fails compilation
- Has linting warnings (unless explicitly documented)
- Contains debug code
- Has unused imports
- Breaks existing functionality
- Has unresolved database questions (always consult MCP first)

### MCP Usage Guidelines
**ALWAYS use MCP when:**
- Creating or modifying database schemas
- Writing database queries or aggregations
- Implementing data validation rules
- Handling data relationships and foreign keys
- Processing API responses with unknown structure
- Debugging data inconsistencies
- Implementing business logic with data constraints
- Working with Firebase/Firestore data structures

**MCP provides accurate information about:**
- Database schema and field types
- Data relationships and constraints
- Query syntax and performance optimization
- API response formats and data structures
- Business logic rules and validation requirements

### Security Considerations
- Never commit secrets or API keys
- Use environment variables for configuration
- Implement proper input validation
- Use HTTPS for all communications
- Implement proper authentication and authorization
- Regular dependency updates for security patches

### Code Review Guidelines
- Review for security vulnerabilities
- Check for performance implications
- Ensure proper error handling
- Verify test coverage
- Check for code duplication
- Ensure proper documentation

## Common Patterns

### Error Handling
```typescript
// Backend
try {
  const result = await someOperation();
  return res.status(200).json({ success: true, data: result });
} catch (error) {
  console.error('Operation failed:', error);
  return res.status(500).json({ 
    success: false, 
    message: 'Internal server error' 
  });
}
```

### API Response Format
```typescript
// Success response
{
  success: true,
  data: T,
  message?: string
}

// Error response
{
  success: false,
  message: string,
  errors?: any[]
}
```

### Flutter Widget Structure
```dart
class FeatureWidget extends StatelessWidget {
  const FeatureWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    return Column(
      children: [
        _buildHeader(),
        _buildContent(),
      ],
    );
  }

  Widget _buildHeader() {
    return AppBar(title: Text('Feature'));
  }

  Widget _buildContent() {
    return Expanded(
      child: ListView.builder(
        itemBuilder: (context, index) => _buildListItem(index),
      ),
    );
  }

  Widget _buildListItem(int index) {
    return ListTile(
      title: Text('Item $index'),
    );
  }
}
```

### Business Logic Structure
```dart
/// Handles user authentication and session management
class AuthService {
  /// Authenticates user with email and password
  /// Returns [AuthResult] with success status and user data
  Future<AuthResult> authenticateUser(String email, String password) async {
    try {
      final credential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (credential.user != null) {
        return AuthResult.success(credential.user!);
      }
      
      return AuthResult.failure('Authentication failed');
    } catch (e) {
      return AuthResult.failure(e.toString());
    }
  }
}
```

## Tools & Dependencies
- Backend: Express, MongoDB, Firebase, TypeScript, ESLint
- Mobile: Flutter, Firebase, Provider/Riverpod
- Development: VS Code, Cursor, Git

## Environment Setup
- Use Node.js 18+ for backend
- Use Flutter 3.0+ for mobile
- Configure Firebase properly for both projects
- Set up proper environment variables
- Use proper linting and formatting tools

Remember: Always prioritize code quality, security, and maintainability over speed of development.
